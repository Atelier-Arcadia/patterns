<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pattern Manager</title>
  <style>
    :root {
      --bg: #0f0f0f;
      --surface: #1a1a1a;
      --surface2: #252525;
      --border: #333;
      --text: #e0e0e0;
      --text-dim: #888;
      --accent: #7c9bff;
      --accent-hover: #9db5ff;
      --danger: #ff6b6b;
      --danger-hover: #ff8a8a;
      --success: #6bffb8;
      --success-hover: #8affd0;
      --warning: #ffcf6b;
      --radius: 8px;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    .container { max-width: 960px; margin: 0 auto; padding: 24px; }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 24px;
      gap: 12px;
    }

    h1 { font-size: 1.5rem; font-weight: 600; }

    .header-actions { display: flex; gap: 8px; align-items: center; }

    .breadcrumb {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 20px;
      font-size: 0.9rem;
      color: var(--text-dim);
    }

    .breadcrumb a { color: var(--accent); text-decoration: none; cursor: pointer; }
    .breadcrumb a:hover { color: var(--accent-hover); }
    .breadcrumb .sep { color: var(--text-dim); }

    .card-list { display: flex; flex-direction: column; gap: 12px; }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      cursor: pointer;
      transition: border-color 0.15s;
    }

    .card:hover { border-color: var(--accent); }
    .card.no-click { cursor: default; }
    .card.no-click:hover { border-color: var(--border); }

    .card-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
    }

    .card-title { font-weight: 600; font-size: 1.05rem; }
    .card-slug { color: var(--text-dim); font-size: 0.85rem; font-family: monospace; }
    .card-desc { color: var(--text-dim); font-size: 0.9rem; margin-top: 4px; }

    .card-actions { display: flex; gap: 6px; flex-shrink: 0; }

    .card-meta {
      display: flex;
      gap: 16px;
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--text-dim);
    }

    button {
      background: var(--surface2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 14px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }

    button:hover { background: var(--border); }
    button.primary { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 500; }
    button.primary:hover { background: var(--accent-hover); border-color: var(--accent-hover); }
    button.danger { color: var(--danger); border-color: var(--danger); }
    button.danger:hover { background: var(--danger); color: #000; }
    button.success { color: var(--success); border-color: var(--success); }
    button.success:hover { background: var(--success); color: #000; }
    button.small { padding: 4px 10px; font-size: 0.8rem; }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: var(--danger);
      color: #000;
      font-size: 0.7rem;
      font-weight: 700;
      min-width: 18px;
      height: 18px;
      border-radius: 9px;
      padding: 0 5px;
      margin-left: 4px;
    }

    .status-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .status-badge.pending { background: var(--warning); color: #000; }
    .status-badge.accepted { background: var(--success); color: #000; }
    .status-badge.rejected { background: var(--danger); color: #000; }

    .impact-warning {
      background: rgba(255, 207, 107, 0.15);
      border: 1px solid var(--warning);
      color: var(--warning);
      padding: 6px 10px;
      border-radius: var(--radius);
      font-size: 0.85rem;
      margin-top: 6px;
    }

    .form-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .form-panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 24px;
      width: 100%;
      max-width: 560px;
      max-height: 90vh;
      overflow-y: auto;
    }

    .form-panel h2 { margin-bottom: 16px; font-size: 1.2rem; }

    .field { margin-bottom: 14px; }
    .field label { display: block; font-size: 0.85rem; color: var(--text-dim); margin-bottom: 4px; }

    .field input, .field textarea, .field select {
      width: 100%;
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 0.9rem;
      font-family: inherit;
    }

    .field textarea { min-height: 120px; resize: vertical; font-family: monospace; font-size: 0.85rem; }
    .field input:focus, .field textarea:focus, .field select:focus { outline: none; border-color: var(--accent); }

    .form-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 18px; }

    .empty-state {
      text-align: center;
      color: var(--text-dim);
      padding: 48px 24px;
      font-size: 0.95rem;
    }

    .pattern-detail { margin-top: 8px; }

    .template-preview {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
      margin-top: 8px;
      font-family: monospace;
      font-size: 0.83rem;
      white-space: pre-wrap;
      color: var(--text-dim);
      max-height: 200px;
      overflow-y: auto;
    }

    .toast {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: var(--surface);
      border: 1px solid var(--success);
      color: var(--success);
      padding: 12px 20px;
      border-radius: var(--radius);
      font-size: 0.9rem;
      z-index: 200;
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

    .submission-target {
      font-size: 0.8rem;
      color: var(--text-dim);
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Pattern Manager</h1>
      <div class="header-actions">
        <button id="btn-submissions" style="display:none">Submissions</button>
        <button class="primary" id="btn-new">+ New</button>
        <button id="btn-auth"></button>
      </div>
    </header>
    <div class="breadcrumb" id="breadcrumb"></div>
    <div class="card-list" id="content"></div>
  </div>

  <script>
    const API = '/api';

    // State
    let currentDomain = null;
    let currentCategory = null;
    let isAdmin = false;
    let adminConfigured = false;
    let viewingSubmissions = false;
    let currentSubmissions = [];

    // -- API helper --

    async function api(method, path, body) {
      const opts = { method, headers: { 'Content-Type': 'application/json' } };
      if (body !== undefined) opts.body = JSON.stringify(body);
      const res = await fetch(API + path, opts);
      const data = await res.json().catch(() => null);
      return { status: res.status, data, headers: res.headers };
    }

    // -- Toast --

    function showToast(msg, duration = 3000) {
      const t = document.createElement('div');
      t.className = 'toast';
      t.textContent = msg;
      document.body.appendChild(t);
      setTimeout(() => t.remove(), duration);
    }

    // -- DOM helper --

    function el(tag, attrs = {}, ...children) {
      const e = document.createElement(tag);
      for (const [k, v] of Object.entries(attrs)) {
        if (k === 'className') e.className = v;
        else if (k.startsWith('on')) e.addEventListener(k.slice(2).toLowerCase(), v);
        else e.setAttribute(k, v);
      }
      for (const c of children) {
        if (typeof c === 'string') e.appendChild(document.createTextNode(c));
        else if (c) e.appendChild(c);
      }
      return e;
    }

    // -- Auth --

    async function checkAuth() {
      const { data } = await api('GET', '/auth/status');
      isAdmin = data?.authenticated || false;
      adminConfigured = data?.adminConfigured || false;
      updateAuthUI();
    }

    function updateAuthUI() {
      const btnAuth = document.getElementById('btn-auth');
      const btnNew = document.getElementById('btn-new');
      const btnSubs = document.getElementById('btn-submissions');

      if (isAdmin) {
        btnAuth.textContent = 'Logout';
        btnAuth.onclick = doLogout;
        btnNew.textContent = '+ New';
        btnNew.style.display = '';
        btnSubs.style.display = '';
        updateSubmissionBadge();
      } else {
        if (adminConfigured) {
          btnAuth.textContent = 'Login';
          btnAuth.onclick = showLoginForm;
        } else {
          btnAuth.style.display = 'none';
        }
        btnNew.textContent = '+ Suggest';
        btnNew.style.display = '';
        btnSubs.style.display = 'none';
      }
    }

    async function updateSubmissionBadge() {
      if (!isAdmin) return;
      const { data } = await api('GET', '/submissions?status=pending');
      const btn = document.getElementById('btn-submissions');
      const count = data?.length || 0;
      btn.innerHTML = '';
      btn.appendChild(document.createTextNode('Submissions'));
      if (count > 0) {
        const badge = el('span', { className: 'badge' }, String(count));
        btn.appendChild(badge);
      }
    }

    function showLoginForm() {
      showForm('Admin Login', [
        { key: 'secret', label: 'Admin Secret', type: 'password', placeholder: 'Enter admin secret' },
      ], async (values) => {
        const { status, data } = await api('POST', '/auth/login', { secret: values.secret });
        if (status === 200) {
          await checkAuth();
          navigateHome();
          showToast('Logged in as admin');
        } else {
          showToast(data?.error || 'Login failed');
        }
      });
    }

    async function doLogout() {
      await api('POST', '/auth/logout');
      isAdmin = false;
      viewingSubmissions = false;
      updateAuthUI();
      navigateHome();
      showToast('Logged out');
    }

    // -- Rendering --

    function renderBreadcrumb() {
      const bc = document.getElementById('breadcrumb');
      bc.innerHTML = '';

      if (viewingSubmissions) {
        const home = el('a', { onClick: () => navigateHome() }, 'Domains');
        bc.appendChild(home);
        bc.appendChild(el('span', { className: 'sep' }, ' / '));
        bc.appendChild(el('span', {}, 'Submissions'));
        return;
      }

      const home = el('a', { onClick: () => navigateHome() }, 'Domains');
      bc.appendChild(home);

      if (currentDomain) {
        bc.appendChild(el('span', { className: 'sep' }, ' / '));
        if (currentCategory) {
          bc.appendChild(el('a', { onClick: () => navigateToDomain(currentDomain.slug) }, currentDomain.name));
          bc.appendChild(el('span', { className: 'sep' }, ' / '));
          bc.appendChild(el('span', {}, currentCategory.name));
        } else {
          bc.appendChild(el('span', {}, currentDomain.name));
        }
      }
    }

    function renderDomains(domains) {
      const content = document.getElementById('content');
      content.innerHTML = '';

      if (domains.length === 0) {
        content.innerHTML = '<div class="empty-state">No domains yet.</div>';
        return;
      }

      for (const d of domains) {
        const catCount = d.categories ? d.categories.length : 0;
        const patCount = d.categories ? d.categories.reduce((s, c) => s + (c.patterns?.length || 0), 0) : 0;

        const actions = [];
        if (isAdmin) {
          actions.push(el('button', { className: 'small', onClick: (e) => { e.stopPropagation(); editDomain(d); } }, 'Edit'));
          actions.push(el('button', { className: 'small danger', onClick: (e) => { e.stopPropagation(); deleteDomain(d.slug); } }, 'Delete'));
        }

        const card = el('div', { className: 'card', onClick: () => navigateToDomain(d.slug) },
          el('div', { className: 'card-header' },
            el('div', {},
              el('div', { className: 'card-title' }, d.name),
              el('div', { className: 'card-slug' }, d.slug),
              el('div', { className: 'card-desc' }, d.description),
            ),
            actions.length > 0 ? el('div', { className: 'card-actions' }, ...actions) : null,
          ),
          el('div', { className: 'card-meta' },
            el('span', {}, `${catCount} categories`),
            el('span', {}, `${patCount} patterns`),
          ),
        );
        content.appendChild(card);
      }
    }

    function renderCategories(categories) {
      const content = document.getElementById('content');
      content.innerHTML = '';

      if (categories.length === 0) {
        content.innerHTML = '<div class="empty-state">No categories yet.</div>';
        return;
      }

      for (const c of categories) {
        const patCount = c.patterns?.length || 0;

        const actions = [];
        if (isAdmin) {
          actions.push(el('button', { className: 'small', onClick: (e) => { e.stopPropagation(); editCategory(c); } }, 'Edit'));
          actions.push(el('button', { className: 'small danger', onClick: (e) => { e.stopPropagation(); deleteCategory(c.slug); } }, 'Delete'));
        }

        const card = el('div', { className: 'card', onClick: () => navigateToCategory(c.slug) },
          el('div', { className: 'card-header' },
            el('div', {},
              el('div', { className: 'card-title' }, c.name),
              el('div', { className: 'card-slug' }, c.slug),
              el('div', { className: 'card-desc' }, c.description),
            ),
            actions.length > 0 ? el('div', { className: 'card-actions' }, ...actions) : null,
          ),
          el('div', { className: 'card-meta' },
            el('span', {}, `${patCount} patterns`),
          ),
        );
        content.appendChild(card);
      }
    }

    function renderPatterns(patterns) {
      const content = document.getElementById('content');
      content.innerHTML = '';

      if (patterns.length === 0) {
        content.innerHTML = '<div class="empty-state">No patterns yet.</div>';
        return;
      }

      for (const p of patterns) {
        const actions = [];
        if (isAdmin) {
          actions.push(el('button', { className: 'small', onClick: () => editPattern(p) }, 'Edit'));
          actions.push(el('button', { className: 'small danger', onClick: () => deletePattern(p.id) }, 'Delete'));
        }
        if (!isAdmin) {
          actions.push(el('button', { className: 'small', onClick: () => suggestModifyPattern(p) }, 'Suggest Edit'));
        }

        const card = el('div', { className: 'card no-click' },
          el('div', { className: 'card-header' },
            el('div', {},
              el('div', { className: 'card-title' }, p.label),
              el('div', { className: 'card-desc' }, p.description),
            ),
            actions.length > 0 ? el('div', { className: 'card-actions' }, ...actions) : null,
          ),
          el('div', { className: 'pattern-detail' },
            el('div', { className: 'card-desc' },
              el('strong', {}, 'Intention: '),
              document.createTextNode(p.intention),
            ),
            el('div', { className: 'template-preview' }, p.template),
          ),
        );
        content.appendChild(card);
      }
    }

    function renderSubmissions(submissions) {
      const content = document.getElementById('content');
      content.innerHTML = '';

      if (submissions.length === 0) {
        content.innerHTML = '<div class="empty-state">No submissions to review.</div>';
        return;
      }

      for (const s of submissions) {
        const actions = [];
        if (s.status === 'pending') {
          actions.push(el('button', { className: 'small success', onClick: () => reviewSubmission(s.id, 'accepted') }, 'Accept'));
          actions.push(el('button', { className: 'small danger', onClick: () => reviewSubmission(s.id, 'rejected') }, 'Reject'));
        }

        const targetInfo = s.type === 'new'
          ? `New pattern for ${s.domainSlug} / ${s.categorySlug}`
          : `Modify pattern #${s.targetPatternId}`;

        const impactWarnings = [];
        if (s.impact?.newDomain) {
          impactWarnings.push(el('div', { className: 'impact-warning' }, `Will create new domain: ${s.impact.newDomain.name} (${s.impact.newDomain.slug})`));
        }
        if (s.impact?.newCategory) {
          impactWarnings.push(el('div', { className: 'impact-warning' }, `Will create new category: ${s.impact.newCategory.name} (${s.impact.newCategory.slug})`));
        }

        const card = el('div', { className: 'card no-click' },
          el('div', { className: 'card-header' },
            el('div', {},
              el('div', { className: 'card-title' }, s.label),
              el('span', { className: `status-badge ${s.status}` }, s.status),
              el('div', { className: 'submission-target' }, targetInfo),
              ...impactWarnings,
              el('div', { className: 'card-desc' }, s.description),
            ),
            actions.length > 0 ? el('div', { className: 'card-actions' }, ...actions) : null,
          ),
          el('div', { className: 'pattern-detail' },
            el('div', { className: 'card-desc' },
              el('strong', {}, 'Intention: '),
              document.createTextNode(s.intention),
            ),
            el('div', { className: 'template-preview' }, s.template),
            el('div', { className: 'card-meta' },
              el('span', {}, `Submitted: ${new Date(s.submittedAt + 'Z').toLocaleString()}`),
              s.reviewedAt ? el('span', {}, `Reviewed: ${new Date(s.reviewedAt + 'Z').toLocaleString()}`) : null,
            ),
          ),
        );
        content.appendChild(card);
      }
    }

    // -- Navigation --

    async function navigateHome() {
      currentDomain = null;
      currentCategory = null;
      viewingSubmissions = false;
      renderBreadcrumb();
      const { data } = await api('GET', '/domains');
      renderDomains(data || []);
    }

    async function navigateToDomain(slug) {
      const { data: domains } = await api('GET', '/domains');
      currentDomain = (domains || []).find(d => d.slug === slug) || null;
      currentCategory = null;
      viewingSubmissions = false;
      renderBreadcrumb();
      if (currentDomain) {
        renderCategories(currentDomain.categories || []);
      }
    }

    async function navigateToCategory(catSlug) {
      const { data: domains } = await api('GET', '/domains');
      const freshDomain = (domains || []).find(d => d.slug === currentDomain.slug);
      if (freshDomain) currentDomain = freshDomain;

      currentCategory = (currentDomain.categories || []).find(c => c.slug === catSlug) || null;
      viewingSubmissions = false;
      renderBreadcrumb();

      if (currentCategory) {
        renderPatterns(currentCategory.patterns || []);
      }
    }

    async function navigateToSubmissions() {
      currentDomain = null;
      currentCategory = null;
      viewingSubmissions = true;
      renderBreadcrumb();
      const { data } = await api('GET', '/submissions');
      currentSubmissions = data || [];
      renderSubmissions(currentSubmissions);
    }

    // -- Forms --

    function showForm(title, fields, onSubmit) {
      const overlay = el('div', { className: 'form-overlay', onClick: (e) => { if (e.target === overlay) overlay.remove(); } },
        el('div', { className: 'form-panel' },
          el('h2', {}, title),
          ...fields.map(f => {
            const isTextarea = f.type === 'textarea';
            const isSelect = f.type === 'select';
            const isPassword = f.type === 'password';
            let input;

            if (isTextarea) {
              input = el('textarea', { id: `field-${f.key}`, placeholder: f.placeholder || '' });
              if (f.value) input.textContent = f.value;
            } else if (isSelect) {
              input = el('select', { id: `field-${f.key}` },
                ...f.options.map(o => {
                  const opt = el('option', { value: o.value }, o.label);
                  if (f.value === o.value) opt.selected = true;
                  return opt;
                })
              );
            } else {
              input = el('input', { id: `field-${f.key}`, type: isPassword ? 'password' : 'text', placeholder: f.placeholder || '' });
              if (f.value) input.value = f.value;
            }

            return el('div', { className: 'field' },
              el('label', { for: `field-${f.key}` }, f.label),
              input,
            );
          }),
          el('div', { className: 'form-actions' },
            el('button', { onClick: () => overlay.remove() }, 'Cancel'),
            el('button', { className: 'primary', onClick: async () => {
              const values = {};
              for (const f of fields) {
                values[f.key] = document.getElementById(`field-${f.key}`).value;
              }
              await onSubmit(values);
              overlay.remove();
            }}, 'Save'),
          ),
        ),
      );
      document.body.appendChild(overlay);
      setTimeout(() => {
        const first = overlay.querySelector('input, textarea, select');
        if (first) first.focus();
      }, 50);
    }

    // -- Suggestion forms (contributor) --

    function showSuggestNewForm() {
      showForm('Suggest New Pattern', [
        { key: 'domainSlug', label: 'Domain', type: 'select', options: [], value: currentDomain?.slug },
        { key: 'categorySlug', label: 'Category', type: 'select', options: [], value: currentCategory?.slug },
        { key: 'label', label: 'Label', placeholder: 'e.g. my-pattern' },
        { key: 'description', label: 'Description', placeholder: 'What this pattern does' },
        { key: 'intention', label: 'Intention', placeholder: 'When the user wants to...' },
        { key: 'template', label: 'Template', type: 'textarea', placeholder: '# Template\n\n{{variable}}' },
      ], async (values) => {
        const { status, data } = await api('POST', '/submissions', {
          type: 'new',
          domainSlug: values.domainSlug,
          categorySlug: values.categorySlug,
          label: values.label,
          description: values.description,
          intention: values.intention,
          template: values.template,
        });
        if (status === 201) {
          showToast('Suggestion submitted for review!');
        } else {
          showToast(data?.error || 'Submission failed');
        }
      });

      // Populate domain/category selects after form renders
      setTimeout(async () => {
        const { data: domains } = await api('GET', '/domains');
        const domainSelect = document.getElementById('field-domainSlug');
        const catSelect = document.getElementById('field-categorySlug');

        if (domainSelect && domains) {
          domainSelect.innerHTML = '';
          for (const d of domains) {
            const opt = el('option', { value: d.slug }, d.name);
            if (d.slug === currentDomain?.slug) opt.selected = true;
            domainSelect.appendChild(opt);
          }

          const updateCategories = () => {
            const selectedDomain = domains.find(d => d.slug === domainSelect.value);
            catSelect.innerHTML = '';
            if (selectedDomain) {
              for (const c of selectedDomain.categories || []) {
                const opt = el('option', { value: c.slug }, c.name);
                if (c.slug === currentCategory?.slug) opt.selected = true;
                catSelect.appendChild(opt);
              }
            }
          };

          domainSelect.addEventListener('change', updateCategories);
          updateCategories();
        }
      }, 60);
    }

    function suggestModifyPattern(p) {
      showForm('Suggest Edit to Pattern', [
        { key: 'label', label: 'Label', value: p.label },
        { key: 'description', label: 'Description', value: p.description },
        { key: 'intention', label: 'Intention', value: p.intention },
        { key: 'template', label: 'Template', type: 'textarea', value: p.template },
      ], async (values) => {
        const { status, data } = await api('POST', '/submissions', {
          type: 'modify',
          targetPatternId: p.id,
          label: values.label,
          description: values.description,
          intention: values.intention,
          template: values.template,
        });
        if (status === 201) {
          showToast('Edit suggestion submitted for review!');
        } else {
          showToast(data?.error || 'Submission failed');
        }
      });
    }

    // -- Admin review --

    async function reviewSubmission(id, decision) {
      const label = decision === 'accepted' ? 'accept' : 'reject';
      let msg = `Are you sure you want to ${label} this submission?`;
      if (decision === 'accepted') {
        const sub = currentSubmissions.find(s => s.id === id);
        if (sub?.impact?.newDomain || sub?.impact?.newCategory) {
          const parts = [];
          if (sub.impact.newDomain) parts.push(`new domain "${sub.impact.newDomain.name}"`);
          if (sub.impact.newCategory) parts.push(`new category "${sub.impact.newCategory.name}"`);
          msg = `This will create ${parts.join(' and ')}.\n\n${msg}`;
        }
      }
      if (!confirm(msg)) return;

      const { status, data } = await api('POST', `/submissions/${id}/review`, { decision });
      if (status === 200) {
        showToast(`Submission ${decision}`);
        navigateToSubmissions();
        updateSubmissionBadge();
      } else {
        showToast(data?.error || 'Review failed');
      }
    }

    // -- CRUD Actions (admin) --

    document.getElementById('btn-new').addEventListener('click', () => {
      if (isAdmin) {
        // Admin: direct CRUD
        if (!currentDomain && !viewingSubmissions) {
          showForm('New Domain', [
            { key: 'name', label: 'Name', placeholder: 'e.g. Software Engineering' },
            { key: 'slug', label: 'Slug', placeholder: 'e.g. software-engineering' },
            { key: 'description', label: 'Description', placeholder: 'Brief description of this domain' },
          ], async (values) => {
            await api('POST', '/domains', values);
            navigateHome();
          });
        } else if (currentDomain && !currentCategory) {
          showForm('New Category', [
            { key: 'name', label: 'Name', placeholder: 'e.g. Features' },
            { key: 'slug', label: 'Slug', placeholder: 'e.g. features' },
            { key: 'description', label: 'Description', placeholder: 'Brief description of this category' },
          ], async (values) => {
            await api('POST', `/domains/${currentDomain.slug}/categories`, values);
            navigateToDomain(currentDomain.slug);
          });
        } else if (currentCategory) {
          showForm('New Pattern', [
            { key: 'label', label: 'Label', placeholder: 'e.g. create-feature-request' },
            { key: 'description', label: 'Description', placeholder: 'What this pattern does' },
            { key: 'intention', label: 'Intention', placeholder: 'When the user wants to...' },
            { key: 'template', label: 'Template', type: 'textarea', placeholder: '# Template\n\n{{variable}}' },
          ], async (values) => {
            await api('POST', `/domains/${currentDomain.slug}/categories/${currentCategory.slug}/patterns`, values);
            navigateToCategory(currentCategory.slug);
          });
        }
      } else {
        // Contributor: suggest
        showSuggestNewForm();
      }
    });

    document.getElementById('btn-submissions').addEventListener('click', () => {
      navigateToSubmissions();
    });

    function editDomain(d) {
      showForm('Edit Domain', [
        { key: 'name', label: 'Name', value: d.name },
        { key: 'description', label: 'Description', value: d.description },
      ], async (values) => {
        await api('PUT', `/domains/${d.slug}`, values);
        navigateHome();
      });
    }

    async function deleteDomain(slug) {
      if (!confirm(`Delete domain "${slug}" and all its categories and patterns?`)) return;
      await api('DELETE', `/domains/${slug}`);
      navigateHome();
    }

    function editCategory(c) {
      showForm('Edit Category', [
        { key: 'name', label: 'Name', value: c.name },
        { key: 'description', label: 'Description', value: c.description },
      ], async (values) => {
        await api('PUT', `/domains/${currentDomain.slug}/categories/${c.slug}`, values);
        navigateToDomain(currentDomain.slug);
      });
    }

    async function deleteCategory(catSlug) {
      if (!confirm(`Delete category "${catSlug}" and all its patterns?`)) return;
      await api('DELETE', `/domains/${currentDomain.slug}/categories/${catSlug}`);
      navigateToDomain(currentDomain.slug);
    }

    function editPattern(p) {
      showForm('Edit Pattern', [
        { key: 'label', label: 'Label', value: p.label },
        { key: 'description', label: 'Description', value: p.description },
        { key: 'intention', label: 'Intention', value: p.intention },
        { key: 'template', label: 'Template', type: 'textarea', value: p.template },
      ], async (values) => {
        await api('PUT', `/patterns/${p.id}`, values);
        navigateToCategory(currentCategory.slug);
      });
    }

    async function deletePattern(id) {
      if (!confirm('Delete this pattern?')) return;
      await api('DELETE', `/patterns/${id}`);
      navigateToCategory(currentCategory.slug);
    }

    // -- Init --
    checkAuth().then(() => navigateHome());
  </script>
</body>
</html>
